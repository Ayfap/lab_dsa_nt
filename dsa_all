Splay TREE

#include <iostream>
using namespace std;

// ================= NODE CLASS =================
class Node {
public:
    int key;
    Node* left;
    Node* right;

    Node(int val) {
        key = val;
        left = right = NULL;
    }
};

// ================= SPLAY TREE CLASS =================
class SplayTree {
private:
    Node* root;

    // -------- RIGHT ROTATION --------
    Node* rightRotate(Node* x) {
        Node* y = x->left;
        x->left = y->right;
        y->right = x;
        return y;
    }

    // -------- LEFT ROTATION --------
    Node* leftRotate(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }

    // -------- SPLAY OPERATION --------
    Node* splay(Node* root, int key) {
        if (root == NULL || root->key == key)
            return root;

        // LEFT SUBTREE
        if (key < root->key) {
            if (root->left == NULL)
                return root;

            // Zig-Zig (LL)
            if (key < root->left->key) {
                root->left->left = splay(root->left->left, key);
                root = rightRotate(root);
            }
            // Zig-Zag (LR)
            else if (key > root->left->key) {
                root->left->right = splay(root->left->right, key);
                if (root->left->right != NULL)
                    root->left = leftRotate(root->left);
            }

            return (root->left == NULL) ? root : rightRotate(root);
        }

        // RIGHT SUBTREE
        else {
            if (root->right == NULL)
                return root;

            // Zag-Zig (RL)
            if (key < root->right->key) {
                root->right->left = splay(root->right->left, key);
                if (root->right->left != NULL)
                    root->right = rightRotate(root->right);
            }
            // Zag-Zag (RR)
            else if (key > root->right->key) {
                root->right->right = splay(root->right->right, key);
                root = leftRotate(root);
            }

            return (root->right == NULL) ? root : leftRotate(root);
        }
    }

    // -------- INORDER --------
    void inorder(Node* root) {
        if (root) {
            inorder(root->left);
            cout << root->key << " ";
            inorder(root->right);
        }
    }

    // -------- PREORDER --------
    void preorder(Node* root) {
        if (root) {
            cout << root->key << " ";
            preorder(root->left);
            preorder(root->right);
        }
    }

    // -------- NORMAL TREE STRUCTURE DISPLAY --------
    void displayTree(Node* root, int space) {
        if (root == NULL)
            return;

        space += 6;

        displayTree(root->right, space);

        cout << endl;
        for (int i = 6; i < space; i++)
            cout << " ";
        cout << root->key << "\n";

        displayTree(root->left, space);
    }

public:
    // -------- CONSTRUCTOR --------
    SplayTree() {
        root = NULL;
    }

    // ================= INSERT =================
    void insert(int key) {
        if (root == NULL) {
            root = new Node(key);
            return;
        }

        root = splay(root, key);

        if (root->key == key)
            return;

        Node* newNode = new Node(key);

        if (key < root->key) {
            newNode->right = root;
            newNode->left = root->left;
            root->left = NULL;
        } else {
            newNode->left = root;
            newNode->right = root->right;
            root->right = NULL;
        }

        root = newNode;
    }

    // ================= SEARCH =================
    void search(int key) {
        root = splay(root, key);

        if (root && root->key == key)
            cout << "Key found and splayed to root!\n";
        else
            cout << "Key not found!\n";
    }

    // ================= DELETE =================
    void deleteKey(int key) {
        if (!root) {
            cout << "Tree is empty!\n";
            return;
        }

        root = splay(root, key);

        if (root->key != key) {
            cout << "Key not found!\n";
            return;
        }

        Node* temp;
        if (!root->left) {
            temp = root;
            root = root->right;
        } else {
            temp = root;
            root = splay(root->left, key);
            root->right = temp->right;
        }

        delete temp;
        cout << "Key deleted successfully.\n";
    }

    // ================= FIND MIN =================
    void findMin() {
        if (!root) {
            cout << "Tree is empty!\n";
            return;
        }

        Node* temp = root;
        while (temp->left)
            temp = temp->left;

        root = splay(root, temp->key);
        cout << "Minimum element: " << temp->key << endl;
    }

    // ================= FIND MAX =================
    void findMax() {
        if (!root) {
            cout << "Tree is empty!\n";
            return;
        }

        Node* temp = root;
        while (temp->right)
            temp = temp->right;

        root = splay(root, temp->key);
        cout << "Maximum element: " << temp->key << endl;
    }

    // ================= DISPLAY =================
    void displayInorder() {
        cout << "Inorder Traversal: ";
        inorder(root);
        cout << endl;
    }

    void displayPreorder() {
        cout << "Preorder Traversal: ";
        preorder(root);
        cout << endl;
    }

    void displayTreeStructure() {
        if (!root) {
            cout << "Tree is empty!\n";
            return;
        }

        cout << "\nSPLAY TREE STRUCTURE:\n";
        displayTree(root, 0);
    }
};

// ================= MAIN FUNCTION =================
int main() {
    SplayTree tree;
    int choice, key;

    while (true) {
        cout << "\n===== SPLAY TREE MENU =====\n";
        cout << "1. Insert\n";
        cout << "2. Search\n";
        cout << "3. Delete\n";
        cout << "4. Inorder Traversal\n";
        cout << "5. Preorder Traversal\n";
        cout << "6. Find Minimum\n";
        cout << "7. Find Maximum\n";
        cout << "8. Display Tree Structure\n";
        cout << "9. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter key: ";
                cin >> key;
                tree.insert(key);
                break;

            case 2:
                cout << "Enter key to search: ";
                cin >> key;
                tree.search(key);
                break;

            case 3:
                cout << "Enter key to delete: ";
                cin >> key;
                tree.deleteKey(key);
                break;

            case 4:
                tree.displayInorder();
                break;

            case 5:
                tree.displayPreorder();
                break;

            case 6:
                tree.findMin();
                break;

            case 7:
                tree.findMax();
                break;

            case 8:
                tree.displayTreeStructure();
                break;

            case 9:
                exit(0);

            default:
                cout << "Invalid choice!\n";
        }
    }
}




// leftist tree 

#include <iostream>
using namespace std;

// ================= NODE CLASS =================
class Node {
public:
    int data;
    Node* left;
    Node* right;
    int npl;   // Null Path Length

    Node(int val) {
        data = val;
        left = right = NULL;
        npl = 0;
    }
};

// ================= LEFTIST HEAP CLASS =================
class LeftistHeap {
private:
    Node* root;

    // -------- MERGE OPERATION (CORE FUNCTION) --------
    Node* merge(Node* h1, Node* h2) {
        // If one heap is empty
        if (h1 == NULL) return h2;
        if (h2 == NULL) return h1;

        // Ensure min-heap property
        if (h1->data > h2->data)
            swap(h1, h2);

        // Merge on right subtree
        h1->right = merge(h1->right, h2);

        // Maintain leftist property: NPL(left) >= NPL(right)
        int leftNPL = (h1->left == NULL) ? -1 : h1->left->npl;
        int rightNPL = (h1->right == NULL) ? -1 : h1->right->npl;

        if (leftNPL < rightNPL)
            swap(h1->left, h1->right);

        // Update NPL
        if (h1->right == NULL)
            h1->npl = 0;
        else
            h1->npl = h1->right->npl + 1;

        return h1;
    }

    // -------- INORDER TRAVERSAL --------
    void inorder(Node* root) {
        if (root) {
            inorder(root->left);
            cout << root->data << " ";
            inorder(root->right);
        }
    }

    // -------- TREE STRUCTURE DISPLAY --------
    void displayTree(Node* root, int space) {
        if (root == NULL)
            return;

        space += 6;

        displayTree(root->right, space);

        cout << endl;
        for (int i = 6; i < space; i++)
            cout << " ";
        cout << root->data << "(npl=" << root->npl << ")\n";

        displayTree(root->left, space);
    }

public:
    // -------- CONSTRUCTOR --------
    LeftistHeap() {
        root = NULL;
    }

    // ================= INSERT =================
    void insert(int key) {
        Node* newNode = new Node(key);
        root = merge(root, newNode);
        cout << "Inserted successfully.\n";
    }

    // ================= FIND MIN =================
    void findMin() {
        if (root == NULL) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "Minimum element: " << root->data << endl;
    }

    // ================= DELETE MIN =================
    void deleteMin() {
        if (root == NULL) {
            cout << "Heap is empty!\n";
            return;
        }

        Node* oldRoot = root;
        root = merge(root->left, root->right);
        delete oldRoot;

        cout << "Minimum element deleted.\n";
    }

    // ================= MERGE WITH ANOTHER HEAP =================
    void mergeWith(LeftistHeap& other) {
        root = merge(root, other.root);
        other.root = NULL;
        cout << "Heaps merged successfully.\n";
    }

    // ================= DISPLAY INORDER =================
    void displayInorder() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "Inorder Traversal: ";
        inorder(root);
        cout << endl;
    }

    // ================= DISPLAY TREE STRUCTURE =================
    void displayStructure() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "\nLEFTIST HEAP STRUCTURE:\n";
        displayTree(root, 0);
    }
};

// ================= MAIN FUNCTION =================
int main() {
    LeftistHeap heap1, heap2;
    int choice, key;

    while (true) {
        cout << "\n===== LEFTIST HEAP MENU =====\n";
        cout << "1. Insert\n";
        cout << "2. Find Minimum\n";
        cout << "3. Delete Minimum\n";
        cout << "4. Inorder Traversal\n";
        cout << "5. Display Tree Structure\n";
        cout << "6. Merge with Another Heap\n";
        cout << "7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value: ";
            cin >> key;
            heap1.insert(key);
            break;

        case 2:
            heap1.findMin();
            break;

        case 3:
            heap1.deleteMin();
            break;

        case 4:
            heap1.displayInorder();
            break;

        case 5:
            heap1.displayStructure();
            break;

        case 6:
            cout << "Enter 3 values to insert into second heap:\n";
            for (int i = 0; i < 3; i++) {
                cin >> key;
                heap2.insert(key);
            }
            heap1.mergeWith(heap2);
            break;

        case 7:
            exit(0);

        default:
            cout << "Invalid choice!\n";
        }
    }
}



//skew heap
#include <iostream>
using namespace std;

// ================= NODE CLASS =================
class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = right = NULL;
    }
};

// ================= SKEW HEAP CLASS =================
class SkewHeap {
private:
    Node* root;

    // -------- MERGE FUNCTION (CORE OF SKEW HEAP) --------
    Node* merge(Node* h1, Node* h2) {
        if (!h1) return h2;
        if (!h2) return h1;

        // Min-heap property: smaller root becomes new root
        if (h1->data > h2->data)
            swap(h1, h2);

        // Recursively merge right child
        h1->right = merge(h1->right, h2);

        // Swap left and right children
        swap(h1->left, h1->right);

        return h1;
    }

    // -------- INORDER TRAVERSAL --------
    void inorder(Node* root) {
        if (root) {
            inorder(root->left);
            cout << root->data << " ";
            inorder(root->right);
        }
    }

    // -------- TREE STRUCTURE DISPLAY --------
    void displayTree(Node* root, int space) {
        if (!root) return;

        space += 6;
        displayTree(root->right, space);

        cout << endl;
        for (int i = 6; i < space; i++)
            cout << " ";
        cout << root->data << "\n";

        displayTree(root->left, space);
    }

public:
    // -------- CONSTRUCTOR --------
    SkewHeap() {
        root = NULL;
    }

    // ================= INSERT =================
    void insert(int key) {
        Node* newNode = new Node(key);
        root = merge(root, newNode);
        cout << "Inserted " << key << " successfully.\n";
    }

    // ================= FIND MIN =================
    void findMin() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "Minimum element: " << root->data << endl;
    }

    // ================= DELETE MIN =================
    void deleteMin() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }

        Node* oldRoot = root;
        root = merge(root->left, root->right);
        delete oldRoot;

        cout << "Minimum element deleted.\n";
    }

    // ================= MERGE WITH ANOTHER HEAP =================
    void mergeWith(SkewHeap& other) {
        root = merge(root, other.root);
        other.root = NULL;
        cout << "Heaps merged successfully.\n";
    }

    // ================= DISPLAY INORDER =================
    void displayInorder() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "Inorder Traversal: ";
        inorder(root);
        cout << endl;
    }

    // ================= DISPLAY TREE STRUCTURE =================
    void displayStructure() {
        if (!root) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "\nSKEW HEAP STRUCTURE:\n";
        displayTree(root, 0);
    }
};

// ================= MAIN FUNCTION =================
int main() {
    SkewHeap heap1, heap2;
    int choice, key;

    while (true) {
        cout << "\n===== SKEW HEAP MENU =====\n";
        cout << "1. Insert\n";
        cout << "2. Find Minimum\n";
        cout << "3. Delete Minimum\n";
        cout << "4. Inorder Traversal\n";
        cout << "5. Display Tree Structure\n";
        cout << "6. Merge with Another Heap\n";
        cout << "7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value: ";
            cin >> key;
            heap1.insert(key);
            break;

        case 2:
            heap1.findMin();
            break;

        case 3:
            heap1.deleteMin();
            break;

        case 4:
            heap1.displayInorder();
            break;

        case 5:
            heap1.displayStructure();
            break;

        case 6:
            cout << "Enter 3 values for second heap:\n";
            for (int i = 0; i < 3; i++) {
                cin >> key;
                heap2.insert(key);
            }
            heap1.mergeWith(heap2);
            break;

        case 7:
            exit(0);

        default:
            cout << "Invalid choice!\n";
        }
    }
}


//binomial


#include <iostream>
#include <cmath>
using namespace std;

// ================= BINOMIAL NODE CLASS =================
class BinomialNode {
public:
    int key;
    int degree;
    BinomialNode* parent;
    BinomialNode* child;
    BinomialNode* sibling;

    BinomialNode(int val) {
        key = val;
        degree = 0;
        parent = child = sibling = NULL;
    }
};

// ================= BINOMIAL HEAP CLASS =================
class BinomialHeap {
private:
    BinomialNode* head;

    // -------- LINK TWO BINOMIAL TREES OF SAME DEGREE --------
    void linkTrees(BinomialNode* y, BinomialNode* z) {
        y->parent = z;
        y->sibling = z->child;
        z->child = y;
        z->degree++;
    }

    // -------- MERGE TWO HEAPS (MERGE ROOT LISTS BY DEGREE) --------
    BinomialNode* merge(BinomialNode* h1, BinomialNode* h2) {
        if (!h1) return h2;
        if (!h2) return h1;

        BinomialNode* head;
        BinomialNode* tail;
        BinomialNode* a = h1;
        BinomialNode* b = h2;

        // Initialize head
        if (a->degree <= b->degree) {
            head = a;
            a = a->sibling;
        } else {
            head = b;
            b = b->sibling;
        }
        tail = head;

        // Merge rest
        while (a && b) {
            if (a->degree <= b->degree) {
                tail->sibling = a;
                a = a->sibling;
            } else {
                tail->sibling = b;
                b = b->sibling;
            }
            tail = tail->sibling;
        }

        if (a) tail->sibling = a;
        else tail->sibling = b;

        return head;
    }

    // -------- UNION TWO HEAPS --------
    BinomialNode* unionHeaps(BinomialNode* h1, BinomialNode* h2) {
        BinomialNode* newHead = merge(h1, h2);
        if (!newHead) return NULL;

        BinomialNode* prev = NULL;
        BinomialNode* curr = newHead;
        BinomialNode* next = curr->sibling;

        while (next) {
            if ((curr->degree != next->degree) ||
                (next->sibling && next->sibling->degree == curr->degree)) {
                prev = curr;
                curr = next;
            } else {
                if (curr->key <= next->key) {
                    curr->sibling = next->sibling;
                    linkTrees(next, curr);
                } else {
                    if (!prev) newHead = next;
                    else prev->sibling = next;
                    linkTrees(curr, next);
                    curr = next;
                }
            }
            next = curr->sibling;
        }
        return newHead;
    }

    // -------- FIND MIN NODE IN ROOT LIST --------
    BinomialNode* findMinNode() {
        if (!head) return NULL;
        BinomialNode* y = NULL;
        BinomialNode* x = head;
        int min = INT32_MAX;

        while (x) {
            if (x->key < min) {
                min = x->key;
                y = x;
            }
            x = x->sibling;
        }
        return y;
    }

    // -------- REVERSE CHILDREN LIST (USED IN EXTRACT MIN) --------
    BinomialNode* reverseList(BinomialNode* node) {
        BinomialNode* prev = NULL;
        BinomialNode* curr = node;
        BinomialNode* next;

        while (curr) {
            next = curr->sibling;
            curr->sibling = prev;
            curr->parent = NULL;
            prev = curr;
            curr = next;
        }
        return prev;
    }

    // -------- DISPLAY ROOT LIST (FOR DEBUG/INORDER-LIKE) --------
    void displayTree(BinomialNode* node, int indent = 0) {
        while (node) {
            for (int i = 0; i < indent; i++) cout << "  ";
            cout << node->key << "\n";
            if (node->child)
                displayTree(node->child, indent + 2);
            node = node->sibling;
        }
    }

public:
    // -------- CONSTRUCTOR --------
    BinomialHeap() { head = NULL; }

    // ================= INSERT =================
    void insert(int key) {
        BinomialNode* temp = new BinomialNode(key);
        head = unionHeaps(head, temp);
        cout << "Inserted " << key << " successfully.\n";
    }

    // ================= FIND MIN =================
    void findMin() {
        BinomialNode* minNode = findMinNode();
        if (!minNode) cout << "Heap is empty!\n";
        else cout << "Minimum element: " << minNode->key << endl;
    }

    // ================= EXTRACT MIN =================
    void extractMin() {
        if (!head) {
            cout << "Heap is empty!\n";
            return;
        }

        // Find min node and its previous
        BinomialNode* prevMin = NULL;
        BinomialNode* minNode = head;
        BinomialNode* prev = NULL;
        BinomialNode* curr = head;
        int min = INT32_MAX;

        while (curr) {
            if (curr->key < min) {
                min = curr->key;
                minNode = curr;
                prevMin = prev;
            }
            prev = curr;
            curr = curr->sibling;
        }

        // Remove minNode from root list
        if (!prevMin) head = minNode->sibling;
        else prevMin->sibling = minNode->sibling;

        // Reverse minNode's children and union
        BinomialNode* childReversed = reverseList(minNode->child);
        head = unionHeaps(head, childReversed);

        delete minNode;
        cout << "Minimum element extracted.\n";
    }

    // ================= MERGE WITH ANOTHER HEAP =================
    void mergeWith(BinomialHeap& other) {
        head = unionHeaps(head, other.head);
        other.head = NULL;
        cout << "Heaps merged successfully.\n";
    }

    // ================= DISPLAY HEAP =================
    void displayHeap() {
        if (!head) {
            cout << "Heap is empty!\n";
            return;
        }
        cout << "\nBINOMIAL HEAP STRUCTURE:\n";
        displayTree(head);
    }
};

// ================= MAIN FUNCTION =================
int main() {
    BinomialHeap heap1, heap2;
    int choice, key;

    while (true) {
        cout << "\n===== BINOMIAL HEAP MENU =====\n";
        cout << "1. Insert\n";
        cout << "2. Find Minimum\n";
        cout << "3. Extract Minimum\n";
        cout << "4. Display Heap\n";
        cout << "5. Merge with Another Heap\n";
        cout << "6. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value: ";
            cin >> key;
            heap1.insert(key);
            break;

        case 2:
            heap1.findMin();
            break;

        case 3:
            heap1.extractMin();
            break;

        case 4:
            heap1.displayHeap();
            break;

        case 5:
            cout << "Enter 3 values for second heap:\n";
            for (int i = 0; i < 3; i++) {
                cin >> key;
                heap2.insert(key);
            }
            heap1.mergeWith(heap2);
            break;

        case 6:
            exit(0);

        default:
            cout << "Invalid choice!\n";
        }
    }
}


//doubly ll


#include <iostream>
using namespace std;

// ================= NODE CLASS =================
class Node {
public:
    int data;
    Node* prev;
    Node* next;

    Node(int val) {
        data = val;
        prev = next = NULL;
    }
};

// ================= DOUBLY LINKED LIST CLASS =================
class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    // -------- CONSTRUCTOR --------
    DoublyLinkedList() {
        head = tail = NULL;
    }

    // ================= INSERT AT BEGINNING =================
    void insertAtBeginning(int val) {
        Node* newNode = new Node(val);
        if (!head) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
        cout << val << " inserted at beginning.\n";
    }

    // ================= INSERT AT END =================
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if (!tail) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
        cout << val << " inserted at end.\n";
    }

    // ================= INSERT AT POSITION =================
    void insertAtPosition(int val, int pos) {
        if (pos <= 1) {
            insertAtBeginning(val);
            return;
        }

        Node* temp = head;
        for (int i = 1; i < pos - 1 && temp; i++) {
            temp = temp->next;
        }

        if (!temp) {
            insertAtEnd(val);
            return;
        }

        Node* newNode = new Node(val);
        newNode->next = temp->next;
        newNode->prev = temp;

        if (temp->next)
            temp->next->prev = newNode;
        else
            tail = newNode;

        temp->next = newNode;
        cout << val << " inserted at position " << pos << ".\n";
    }

    // ================= DELETE FROM BEGINNING =================
    void deleteFromBeginning() {
        if (!head) {
            cout << "List is empty.\n";
            return;
        }

        Node* temp = head;
        head = head->next;
        if (head)
            head->prev = NULL;
        else
            tail = NULL;

        cout << temp->data << " deleted from beginning.\n";
        delete temp;
    }

    // ================= DELETE FROM END =================
    void deleteFromEnd() {
        if (!tail) {
            cout << "List is empty.\n";
            return;
        }

        Node* temp = tail;
        tail = tail->prev;
        if (tail)
            tail->next = NULL;
        else
            head = NULL;

        cout << temp->data << " deleted from end.\n";
        delete temp;
    }

    // ================= DELETE AT POSITION =================
    void deleteAtPosition(int pos) {
        if (!head) {
            cout << "List is empty.\n";
            return;
        }

        if (pos <= 1) {
            deleteFromBeginning();
            return;
        }

        Node* temp = head;
        for (int i = 1; i < pos && temp; i++) {
            temp = temp->next;
        }

        if (!temp) {
            cout << "Position out of range.\n";
            return;
        }

        if (temp->prev)
            temp->prev->next = temp->next;
        if (temp->next)
            temp->next->prev = temp->prev;
        else
            tail = temp->prev;

        cout << temp->data << " deleted from position " << pos << ".\n";
        delete temp;
    }

    // ================= SEARCH ELEMENT =================
    void search(int val) {
        Node* temp = head;
        int pos = 1;
        while (temp) {
            if (temp->data == val) {
                cout << val << " found at position " << pos << ".\n";
                return;
            }
            temp = temp->next;
            pos++;
        }
        cout << val << " not found in the list.\n";
    }

    // ================= DISPLAY FORWARD =================
    void displayForward() {
        if (!head) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List (forward): ";
        Node* temp = head;
        while (temp) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;
    }

    // ================= DISPLAY BACKWARD =================
    void displayBackward() {
        if (!tail) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List (backward): ";
        Node* temp = tail;
        while (temp) {
            cout << temp->data << " ";
            temp = temp->prev;
        }
        cout << endl;
    }
};

// ================= MAIN FUNCTION =================
int main() {
    DoublyLinkedList dll;
    int choice, val, pos;

    while (true) {
        cout << "\n===== DOUBLY LINKED LIST MENU =====\n";
        cout << "1. Insert at Beginning\n";
        cout << "2. Insert at End\n";
        cout << "3. Insert at Position\n";
        cout << "4. Delete from Beginning\n";
        cout << "5. Delete from End\n";
        cout << "6. Delete at Position\n";
        cout << "7. Search\n";
        cout << "8. Display Forward\n";
        cout << "9. Display Backward\n";
        cout << "10. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value: ";
            cin >> val;
            dll.insertAtBeginning(val);
            break;

        case 2:
            cout << "Enter value: ";
            cin >> val;
            dll.insertAtEnd(val);
            break;

        case 3:
            cout << "Enter value: ";
            cin >> val;
            cout << "Enter position: ";
            cin >> pos;
            dll.insertAtPosition(val, pos);
            break;

        case 4:
            dll.deleteFromBeginning();
            break;

        case 5:
            dll.deleteFromEnd();
            break;

        case 6:
            cout << "Enter position: ";
            cin >> pos;
            dll.deleteAtPosition(pos);
            break;

        case 7:
            cout << "Enter value to search: ";
            cin >> val;
            dll.search(val);
            break;

        case 8:
            dll.displayForward();
            break;

        case 9:
            dll.displayBackward();
            break;

        case 10:
            exit(0);

        default:
            cout << "Invalid choice!\n";
        }
    }
}
